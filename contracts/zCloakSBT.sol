pragma solidity >=0.8.0 <0.9.0;

//SPDX-License-Identifier: Apache-2.0
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import {Base64} from "base64-sol/base64.sol";
import {Tokens} from "./libs/Tokens.sol";

error Soulbound();
error MintDisabled();
error SendFailed();
error InvalidSignature();
error ZeroSignature();
error DoesNotExist();
error MintInfoInvalid();
error AlreadyMint();
error DigestAlreadyRevoked();

contract zCloakSBT is ERC721Enumerable, Ownable, ReentrancyGuard {
    using Counters for Counters.Counter;
    using Strings for uint256;

    /*///////////////////////////////////////////////////////////////
 TOKEN STORAGE
 //////////////////////////////////////////////////////////////*/

    Counters.Counter private _tokenIds;

    bool public mintOpen;

    mapping(uint256 => Tokens.TokenOnChain) private _tokenDB;

    // avoid mint multiple SBT of the same tokenInfo, we need to add a registry to flag that(recipient, verifier, digest, programHash) => tokenID
    mapping(address => mapping(address => mapping(bytes32 => mapping(bytes32 => uint256))))
        private _onlyTokenID;

    // A storage for the attester to revoke certain VC, thus the SBT should be burn therefore(if not mint yet, forbid its mint in the future) (attester, digest)
    mapping(address => mapping(bytes32 => bool)) private _revokeDB;

    // Record all SBT(tokenID) minted by the specific digest (attester, digest) => tokenID[]
    mapping(address => mapping(bytes32 => uint256[]))
        private _digestConvertCollection;

    /*///////////////////////////////////////////////////////////////
 EVENTS
 //////////////////////////////////////////////////////////////*/

    event MintSuccess(address indexed recipent, uint256 indexed tokenID);
    event RevokeSuccess(address indexed attester, uint256[] tokenIDList);
    /*///////////////////////////////////////////////////////////////
 EIP-712 STORAGE
 //////////////////////////////////////////////////////////////*/

    uint256 internal immutable INITIAL_CHAIN_ID;

    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;

    /*///////////////////////////////////////////////////////////////
 STRUCTOR
 //////////////////////////////////////////////////////////////*/

    constructor() ERC721("zCloak SBT", "zkSBT") {
        INITIAL_CHAIN_ID = block.chainid;
        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();
    }

    /*///////////////////////////////////////////////////////////////
 PLEDGE LOGIC
 //////////////////////////////////////////////////////////////*/

    /**
     * @notice Mint a zkSBT according to the TokenInfo and the Signature generated by the ZKP Verifier
     */
    //prettier-ignore
    function mint(Tokens.Token memory tokenInfo, bytes memory verifierSignature) public payable nonReentrant {

        if (mintOpen == false) revert MintDisabled();

        // Make sure the SBT hasn't been mint yet
        if (_onlyTokenID[tokenInfo.recipient][tokenInfo.verifier][tokenInfo.digest][tokenInfo.programHash] != 0){
            revert AlreadyMint();
        }

        if (_revokeDB[tokenInfo.attester][tokenInfo.digest] == true) {
            revert DigestAlreadyRevoked();
        }
        // Verify the signature first, then mint
        bool isTokenInfoValid = Tokens.verifySignature(tokenInfo, verifierSignature);
        if (isTokenInfoValid == false) revert MintInfoInvalid();

        _tokenIds.increment();
        uint256 id = _tokenIds.current();
        _mint(tokenInfo.recipient, id);
        Tokens.TokenOnChain memory tokenOnChainInfo = Tokens.fillTokenOnChain(tokenInfo, _time());
        _tokenDB[id] = tokenOnChainInfo;

        // todo: to check the new id is added successfully
        _digestConvertCollection[tokenOnChainInfo.attester][tokenOnChainInfo.digest].push(id);

        emit MintSuccess(Tokens.getRecipient(tokenInfo), id);
    }

    /**
     * @notice A function for attesters to register the revoked VC digest, which thus burn the SBT made by the digest, and if not mint yet, forbid its mint in the future
     */
    //prettier-ignore
    function revokeByDigest(bytes32 digest) public {
        if (_revokeDB[msg.sender][digest] == true) {
            revert DigestAlreadyRevoked();
        }

        _revokeDB[msg.sender][digest] == true;
        uint256[] memory revokeList = _digestConvertCollection[msg.sender][digest];
        for (uint i = 0; i < revokeList.length; i++){
            super._burn(revokeList[i]);
        }
        emit RevokeSuccess(msg.sender, revokeList);
    }

    /**
     * @notice Check whether a zkSBT is valid, check its existance, expirationDate not reach and it hasn't been revoked.
     * add verifier list.
     */
    //prettier-ignore
    function checkValidity(uint256 id, address[] ) public view returns (bool) {
        // check its existance
        // todo: do a test -- check if an attester revoked, wheather it is still exsit?
        if (!_exists(id)) return false;

        // check its expirationDate
        if (_tokenDB[id].expirationTimestamp >= _time()){
            return false;
        }
        return true;
    }

    /**
     * @notice Receives json from constructTokenURI
     */
    // prettier-ignore
    function tokenURI(uint256 id) public view override returns (string memory) {
        if (!_exists(id)) revert DoesNotExist();
        // todo: dertermine whether need's title and description for each SBT.
        return _tokenDB[id].sbtFigure;
    }

    function contractURI() external pure returns (string memory) {
        string
            memory collectionImage = "ar://MzXyO8ZH3dyyp9wdXAVuUT57vGLFifs3TnskClOoFSQ";
        string memory json = string.concat(
            '{"name": "zCloak SBT","description":"This is a zkSBT collection launched by zCloak Network which can be used to represent ones personal identity without revealing their confidential information","image":"',
            collectionImage,
            '"}'
        );
        return string.concat("data:application/json;utf8,", json);
    }

    /**
     * @notice Toggles Pledging On / Off
     */
    function toggleMinting() public onlyOwner {
        mintOpen == false ? mintOpen = true : mintOpen = false;
    }

    /*///////////////////////////////////////////////////////////////
 TOKEN LOGIC
 //////////////////////////////////////////////////////////////*/

    /**
     * @notice SOULBOUND: Block transfers.
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 firstTokenId,
        uint256 batchSize
    ) internal virtual override(ERC721Enumerable) {
        require(
            // can only be mint by address `0` and can be (burn by) transfered to the opensea burn address
            from == address(0) ||
                to == address(0x000000000000000000000000000000000000dEaD),
            "SOULBOUND: Non-Transferable"
        );
        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);
    }

    /**
     * @notice SOULBOUND: Block approvals.
     */
    function setApprovalForAll(
        address operator,
        bool _approved
    ) public virtual override(ERC721, IERC721) {
        revert Soulbound();
    }

    /**
     * @notice SOULBOUND: Block approvals.
     */
    function approve(
        address to,
        uint256 tokenId
    ) public virtual override(ERC721, IERC721) {
        revert Soulbound();
    }

    /**
     * @notice https://eips.ethereum.org/EIPS/eip-712
     * todo : here, need to modify the EIP712 domain struct, etc.
     */
    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {
        return
            block.chainid == INITIAL_CHAIN_ID
                ? INITIAL_DOMAIN_SEPARATOR
                : computeDomainSeparator();
    }

    function computeDomainSeparator() internal view virtual returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    keccak256(
                        "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
                    ),
                    keccak256(bytes("zCloakSBT")),
                    keccak256(bytes("0")),
                    block.chainid,
                    address(this)
                )
            );
    }

    /**
     * @dev Returns the current's block timestamp. This method is overridden during tests and used to simulate the
     * current block time.
     */
    function _time() internal view returns (uint64) {
        return uint64(block.timestamp);
    }
}
